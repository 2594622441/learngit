# CSS为网页添加样式
[toc]
## 术语解释
```元素选择器添加样式：
<style>
    h1{
        color: red;
        background-color: lightblue;
        text-align: center;
    }
</style>
```
CSS规则 = 选择器 + 声明块
`选择器用来选中元素以确定样式的范围，声明块`

### 选择器
1.ID选择器：选中的是对应id值的元素（选中所有该元素，用的较少）
```
<style>
    #指定元素对应的id {
        color:red;
        background-color:lightblue;
        tect-align:center;
    }
</style>
```

2.元素选择器（只选择一个，用的是少）
```
<style>
    元素名称{
        color: red;
        background-color: lightblue;
        text-align: center;
    }
</style>
```
3.类选择器（用的最多）
```
<style>
    .类名称{
        color: red;
        background-color: lightblue;
        text-align: center;
    }
</style>
```


总结：
1.id选择器：#id名称{}
2.元素选择器：元素名称{}
3.类选择器：.类名称{}
### 声明块
声明块中包含许多声明（属性），每一个声明表达了某一个样式规则。

## CSS代码书写位置
1.内部样式表，
`
书写在style元素中，建议style元素写在head中
`
2.内联样式表（元素样式表），JS常用，不推荐使用
`
直接书写在元素的属性的位置，范围上相当于id选择
`
3.外部样式表（推荐使用）
`
将样式书写到独立的CSS文件中
`
    1）可以解决多个页面样式重复的问题
    2）有利于浏览器缓存，从而提高页面响应速度
    3）有利于代码分离(HTML和CSS)，便于阅读和维护

# 常见的样式声明

1.color:元素内部的文字颜色(定义好的单词/rgb/hex16进制)
2.background-color：元素背景颜色
3.font-size;元素内部文字的尺寸大小
    1）px:像素，绝对单位
    2）em：相对父元素字体大小的倍数，相对单位
    3）user agent：UA，用户代理（浏览器）
4.font-weight：文字粗细程度，取值为数字/预设值（单词）
    1）normal：默认值，400
    2）bold：加粗，700
5.font-family：文字类型，必须用户计算机中已存在的字体才有效
    1）微软雅黑
    2）宋体
    3）黑体
    4）sans-serif:非衬线字体
    。。。
6.font-style：字体样式，通常用于设置斜体字
    1）italic：倾斜
    2）i元素：默认其中的文字为倾斜字体，实际使用中用它表示一个图标（icon）
    3）strong和em元素：默认带有加粗效果，strong元素表示重要的不可忽略的，em表示强调的内容
7.text-decoration：文本修饰（给文本加线）
    1）line-through：中间加线（表示删除的del元素和表示过期的s元素的时候常用）
    2）overline：上面加线
    3）underline：下划线
8.text-indent：首行文本缩进
    1）px:像素
    2）em:字符数
9.line-height：行高，每行文本的高度
    1）px:像素
    2）em:通常不用
    3）纯数字，表示相对于当前元素的大小
    4）normal
    。。。
10.width：宽度
11.height：高度
12.letter-space：文字间隙
    1）px
    2）em
13.text-align：元素内部文字的排列方式
    1）left
    2）center
    3）right

# 选择器
选择器的作用：帮助你精准的选中想要的元素
## 简单选择器
1.id选择器： #id{}
2.元素选择器：元素名{}
3.类选择器：.类名{}
4.通配符选择器：*{}， 表示选中所有元素
5.属性选择器：[属性]{}，带有该属性的元素均被选中，
            或 [属性=xxx]{}，指定属性值的，对元素的选择，
            或 [属性~=xxx]{},属性值列表中中含有xxx,且列表是以空格隔开的，
            或 [属性*=xxx]{},属性值列表中中含有xxx，
            或 [属性^=xxx]{},属性值以xxx开头，
            或 [属性&=xxx]{}，属性值以xxx结尾
            
6.伪类选择器：选中某些元素的某种状态，元素名:状态名{}
    1）link：超链接未访问时的状态，a:link{}
    2）visited：超链接访问后的状态，a:visited{}
    3）hover：鼠标悬停状态，元素名:hover{}
    4）active：激活状态（鼠标按下），元素名：active{}
    按1）2）3）4）的顺序书写，爱恨法则，love hate：l, v, h, a

7.伪元素选择器：元素名::伪元素名
    1）before：span::before{}
    2）after: span::after{}
    3）content为before和after中的属性
    `如<span>三国</span>和span::before{content:"《"} span::after{content:"》"}会得到《三国》`


## 选择器的组合（使用连接符）
1.并且 —— 直接结合
1.后代元素 —— 空格
2.子元素 —— >
3.后面的一个相邻兄弟元素 —— +
4.后面的所有兄弟元素 —— ~


## 选择器的并列（用","分隔）
多个选择器，用逗号分割，是个语法糖

# 层叠（权重计算）
声明冲突：同一个样式，多次应用到同一元素
层叠:解决声明冲突的过程，浏览器自动处理
## 1.比较重要性
重要性从高到低：
1）作者样式表（开发者书写的样式）中的!important样式（不建议使用）
2）作者样式表的普通样式
3）浏览器默认样式表中的样式

## 2.比较特殊性（看选择器）
重要性相同时，比较特殊性：
1）总体规则：选择器选中的范围越小，越特殊
2）具体规则：通过选择器计算出一个4位数
    千位：如果是内联样式，记作1，否则记作0
    百位：选择器中所有id选择器的数量
    十位：所有类选择器、属性选择器、伪类选择器的数量
    个位：所有元素选择器、伪元素选择器的数量

## 3.比较源次序
重要性和特殊性都相同时，比较源次序：书写代码靠后的优先级高

## 应用
1.重置样式表：书写一些作者样式表覆盖浏览器的默认样式
`
常见的重置样式表：normalize.css, reset.css, meyer.css
`
2.爱恨法则(和源次序有关)
`
link > visited > hover > active
`

# 继承
子元素会继承父元素的某些CSS属性
`通常，跟文本内容有关的属性，会被继承。`

# CSS属性值的计算过程（一个元素从所有属性都没有值，到都有值的过程）
## 页面的渲染过程
```
1）一个一个元素依次渲染
2）渲染顺序，按照页面文档的树形结构依次进行（外层->内层，深度优先）
3）前提条件：该元素的所有CSS属性必须有值（所有CSS属性）
```
## 计算步骤：
1）确定声明值：参考样式表（作者/浏览器默认）中没有冲突的声明，作为CSS的属性值
2）层叠冲突：对样式表中有冲突的声明使用层叠规则，确定CSS属性值
3）使用继承：对仍然没有值的属性，若可以继承，则继承父元素的值
4）使用默认值：对仍然没有值的属性，使用默认值（所有的CSS属性均有默认值）

## 特殊的两个CSS取值：
1）inherit：手动（强制）继承
2）initial：初始值，即默认值

# 盒模型
box：每个元素在页面中都会生成一个矩形区域（盒子）
## 盒子类型
>1）行盒：CSS属性display为inline的元素，不换行(span、a、        img、video、audio等)
    如，span元素，默认为行盒
>2）块盒：display为block的元素，独占一行（容器元素、h1~h6、p）
    如，div元素，默认是块盒

## 盒子的组成部分(快递盒)
>1）内容: content(快递实物)，通常叫做整个盒子的**内容盒**：
    `width和height设置的是盒子内容的宽高`
>2）填充: padding(泡沫填充)，又名内边距：
    `盒子边框到盒子内容的距离`
    padding-top、padding-bottom、padding-left、padding-right
    简写属性：padding：上 右 下 左，或padding：上下 左右，
    或padding：上下左右
    填充区 + 内容区 = **填充盒**
>3）边框: border(边框 = 边框样式 + 边框宽度 + 边框颜色):
    border-width和border-style设置边框，border-style默认值为none，此时border不显示，border-color默认为内容文本的颜色
    边框 + 填充区 + 内容区 = **边框盒**
>4）外边距: margin（边框和其他盒子之间的距离）

# 盒模型应用
## 改变宽高范围
默认情况下，width盒height设置的是内容盒的宽高
>页面重构师：将psd文件（设计稿）制作为静态页面。
    衡量设计稿尺寸的时候，往往使用的是边框盒，但设置width盒height则设置的是内容盒
    1）精确计算：边框盒尺寸-边框尺寸 = 内容盒尺寸
    2）CSS3：box-sizing， 令box-sizing: border-size则width和height设置的尺寸即为边框盒的尺寸
## 改变背景覆盖范围
默认情况下，背景覆盖边框盒，可以通过background-clip进行修改
## 溢出处理
>默认情况会自动调整宽高(如果没有设置值):
    overflow控制内容溢出边框盒后的处理方式，默认为visiable,可设置为hidden或scroll或auto。
## 断词规则（word-break，一般不设置，使用默认值）
>影响文字在什么位置被截断（换行）
    1）normal：普通。CJK字符（单个字符位置截断），非CJK字符（单词位置截断）
    2）breal-all；截断所有。所有字符都在单个字符位置截断（和CJK字符相同）
    3）keep-all：保持所有。所有字符都在单词位置截断（和单词一样）
## 空白处理
如，文字过多时，不换行，在最末尾显示...
>即 white-space: nowrap;
    over-flow: hidden;
    text-overflow: ellipsis;
这三个属性同时设置，即可达到上述效果

# 行盒盒模型
常见的行盒：包含具体内容的元素
span, strong, em, i, img, video, audio等
## 显著特点
>
    1.盒子沿着内容延伸
    2.行盒不能设置宽高：
    调整行盒的宽高，应该使用字体大小、行高、字体类型来间接调整。
    3.内边距padding和边框border和外边框margin：
    水平方向有效，垂直方向仅会影响背景，不会占据空间。
## 行块盒，display：inline-block
即可设置宽高的行盒，且独占一行。开发中经常用来做分页。
>
    1.不独占一行
    2.但盒模型中所有尺寸都有效，可以设置宽高等
## 空白折叠
空白折叠，发生在**行（块）盒内部**或**行（块）盒之间**
## 可替换元素盒非可替换元素
>
    1.大部分元素，页面上显示的结果，取决于元素的内容，称为**非可替换元素**。
    2.少部分元素，页面上显示的结果，取决于元素属性，称为**可替换元素**。
`
可替换元素：img，video，audio等，绝大部分均为行盒。
可替换元素类似于行块盒，盒模型中所有尺寸均有效。
`

# 常规流
1)盒模型：规定单个盒子的规则。
2)视觉格式化模型（布局规则）：页面中的多个盒子排列规则。

视觉格式化模型，大体上将页面中的盒子的排列分为三种方式：
1）常规流
2）浮动
3）定位

## 常规流布局
>
    又称常规流、文档流、普通文档流、常规文档流等.

    所有元素，默认情况下，都属于常规流布局

    总体规则：块盒独占一行，行盒水平方向依次排列

包含块（containing block）：每个盒子都有它的包含块，决定了盒子的活动范围。
`
绝大部分情况下，盒子的包含块，为其父元素的内容盒
`
### 块盒的规则
>1.每个块盒的总宽度，必须刚好等于包含块（父元素的内容盒）的宽度
    auto：将剩余空间吸收掉。

    宽度的默认值是auto，margin的默认值是0，
    width的吸收能力强于margin，都为auto时width生效。
    `
    若 宽度、边框、内边距、外边距计算后，仍然有剩余空间，该空间被margin-right吸收
    `
    在**常规流**中，**块盒**在其包含块中，可以**定宽**，然后**左右margin设置为auto**。
>2.每个宽度，垂直方向上的auto值（表示适应内容的高度）
    height：auto，适应内容的高度

    margin-top/bottom：auto，为0
>3.百分比取值
    padding，margin，宽度可以取值为百分比，即相对于包含块的**宽度**。
    
    即，padding-top/bottom margin-top/bottom也是相对于包含块的**宽度**。
>4.**高度**的百分比
    1)包含块的高度取决于子元素的高度，设置百分比无效

    2)包含块的高度不取决于子元素的高度，百分比相对于父元素高度
>5.上下外边距的合并
    两个常规流块盒，上下边距**相邻**，会进行合并，成为一个。
    两个外边距取最大值。





# 浮动
视觉格式化模型，大体上将页面中的盒子的排列分为三种方式：

1.常规流

2.浮动

3.定位

## 应用场景
1.文字环绕

2.横向排列
## 浮动的基本特点
修改float属性值为：
>left：左浮动，元素靠上靠左
>right:右浮动，元素靠上靠右
默认值为none

1.当一个元素浮动后，元素必定为块盒（display属性变为block）

2.浮动元素的包含块和常规流一样，为父元素的内容盒
## 盒子尺寸
1.宽度为auto时，适应内容宽度，而不是吸收

2.高度为auto时，与常规流一致，适应内容的高度

3.margin为auto时，为0

4.边框，内边距，百分比设置与常规流一样
## 盒子排列
>1.左浮动的盒子靠上靠左排列
>2.右浮动的盒子靠上靠右排列
>3.浮动盒子在包含块中排列时，会避开常规流盒子
>4.常规流块盒在排列时，无视浮动盒子
>5.行盒在排列时，会避开浮动盒子
>6.外边距合并不会发生
    如果文字没有在行盒中，浏览器会自动生成一个行盒（匿名行盒）将其包裹起来。
## 高度坍塌
原因：常规流盒子分自动高度，在计算时，不会考虑浮动盒子。

解决方案：清除浮动，涉及CSS属性：clear
>默认值：none
    left：清除左浮动，该元素必须出现在前面所有左浮动盒子的下方
    right:清除右浮动，该元素必须出现在前面所有右浮动盒子的下方
    both：清除左右浮动

